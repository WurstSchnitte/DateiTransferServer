// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TSocket.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

#include <iostream>
#include <fstream>
#include <vector>
using namespace std;

#include "DateiTransfer.h"
#include "Dateien.h"

string globalip = "";

class DateiTransferHandler : virtual public DateiTransferIf {
public:

    DateiTransferHandler() {
        // Your initialization goes here
    }

    void initUpload(initUploadReturn& _return, const std::string& dateiname, const int64_t dateigroese) {
        // Your implementation goes here
        printf("initUpload\n");
        sendeAnfrageReturn re = initialeSendeAnfrage(dateiname, globalip, dateigroese);
        _return.neuePosition = re.naechstesPaket;
        _return.verbindungsId = re.verbindungsid;
    }

    void initDownload(initDownloadReturn& _return, const std::string& dateiname) {
        // Your implementation goes here
        printf("initDownload\n");
        ladeAnfrageReturn re = initialeLadeAnfrage(dateiname, globalip);
        _return.dateiGroese = re.dateigroese;
        _return.neuePosition = re.naechstesPaket;
        _return.verbindungsId = re.verbindungsid;
    }

    int32_t checkoutPacketSize(const int32_t verbindungsid, const int32_t paketgroese) {
        // Your implementation goes here
        printf("checkoutPacketSize\n");
        return paketGroeseFestlegen(verbindungsid,paketgroese);
    }

    int64_t sendPacket(const int32_t verbindungsid, const std::vector<int8_t> & paket, const int64_t neuedateiposition) {
        // Your implementation goes here
        printf("sendPacket\n");
        const signed char* pa = paket.data();
        return paketEmpfangen(verbindungsid, pa, neuedateiposition);
    }

    void receivePacket(datenSenden& _return, const int32_t verbindungsid, const int64_t dateiposition) {
        // Your implementation goes here
        printf("receivePacket\n");
        paketSendenReturn re = paketSenden(verbindungsid, dateiposition);
        _return.neuePosition = re.naechstesPaket;
        vector<int8_t> out{};
        for(int i = 0; i < (re.naechstesPaket-dateiposition); ++i){
            out.push_back(re.paket[i]);
        }
        _return.paket = out;
    }

};

class DateiTransferCloneFactory : virtual public DateiTransferIfFactory {
public:

    virtual ~DateiTransferCloneFactory() {
    }

    virtual DateiTransferIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) {
        boost::shared_ptr<TSocket> sock = boost::dynamic_pointer_cast<TSocket>(connInfo.transport);
        globalip = sock->getPeerHost();
        return new DateiTransferHandler;
    }

    virtual void releaseHandler(DateiTransferIf* handler) {
        delete handler;
    }
};

int main(int argc, char **argv) {
    init();

    int port = 9090;
    boost::shared_ptr<DateiTransferIfFactory> handler(new DateiTransferCloneFactory());
    boost::shared_ptr<TProcessorFactory> processor(new DateiTransferProcessorFactory(handler));

    boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
    boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
    boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    server.serve();
    release();
    return 0;
}

